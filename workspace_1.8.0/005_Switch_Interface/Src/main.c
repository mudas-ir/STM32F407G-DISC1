/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdint.h>

#define BIT(n) (1U << (n))

#define RCC_AHB1ENR (*((volatile uint32_t *)0x40023830))

#define GPIOA_MODER (*((volatile uint32_t *)0x40020000))
#define GPIOA_PUPDR	(*((volatile uint32_t *)0x4002000C))
#define GPIOA_IDR	(*((volatile uint32_t *)0x40020010))

#define GPIOD_MODER (*((volatile uint32_t *)0x40020C00))
#define GPIOD_ODR	(*((volatile uint32_t *)0x40020C14))

#define RCC_CR 		(*((volatile uint32_t *)0x40023800))
#define RCC_PLLCFGR (*((volatile uint32_t *)0x40023804))
#define RCC_CFGR 	(*((volatile uint32_t *)0x40023808))
#define FLASH_ACR 	(*((volatile uint32_t *)0x40023C00))


int main(void)
{
	// Configuring Clock to 168MHz
	///*

	RCC_CR |= BIT(16);	// HSEON
	while(!(RCC_CR & BIT(17)));	// Wait for HSERDY

	FLASH_ACR =
	    (1 << 8) |   // Instruction cache enable
	    (1 << 9) |   // Data cache enable
	    (1 << 10) |  // Prefetch enable
	    (5 << 0);    // 5 wait states (168 MHz @ 3.3V)


	RCC_PLLCFGR =
	    (8 << 0)  |   // PLLM = 8
	    (336 << 6)|   // PLLN = 336
	    (0 << 16) |   // PLLP = 2 (00 = /2)
	    (1 << 22);    // PLL source = HSE

	RCC_CR |= (1 << 24);          // PLLON
	while (!(RCC_CR & (1 << 25))); // Wait for PLLRDY

	RCC_CFGR |=
	    (0 << 4)  |   // AHB prescaler = /1
	    (5 << 10) |   // APB1 prescaler = /4
	    (4 << 13);    // APB2 prescaler = /2

	RCC_CFGR |= (2 << 0);                 // SW = PLL
	while (((RCC_CFGR >> 2) & 3) != 2);   // Wait until PLL used

	//*/
	//	Enable Clock to port A & D
	RCC_AHB1ENR |= (BIT(0)|BIT(3));

	//	Configure PA0
	GPIOA_MODER &= ~(BIT(0)|BIT(1)); //	make PA0 as Input
	GPIOA_PUPDR &= ~BIT(0);
	GPIOA_PUPDR |= 	BIT(1);			// make PA0 as PullDown

	// Configure PD13
	GPIOD_MODER |= BIT(26);
	GPIOD_MODER &= ~BIT(27);	// make PD13 as Output
	GPIOD_ODR &= ~BIT(13);		// initially make PD13 as LOW

	while(1)
	{
		if((GPIOA_IDR & BIT(0)))
			GPIOD_ODR |= BIT(13);
		else
			GPIOD_ODR &= ~BIT(13);
	}
	return 0;
}
