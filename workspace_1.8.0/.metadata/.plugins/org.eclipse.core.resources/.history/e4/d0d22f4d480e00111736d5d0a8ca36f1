///**
// ******************************************************************************
// * @file           : main.c
// * @author         : Mudassir
// * @brief          : Main program body
// ******************************************************************************
// * @attention
// *
// * Copyright (c) 2026 STMicroelectronics.
// * All rights reserved.
// *
// * This software is licensed under terms that can be found in the LICENSE file
// * in the root directory of this software component.
// * If no LICENSE file comes with this software, it is provided AS-IS.
// *
// ******************************************************************************
// */
//
//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif
//
//#include <stdio.h>
//#include <stdint.h>
//#include "main.h"
//
////	Global Variables
//uint32_t psp_of_task[MAX_TASK] = {TASK1_STACK_START, TASK2_STACK_START, TASK3_STACK_START, TASK4_STACK_START};
//uint32_t Task_Handler_Address[MAX_TASK];
//uint8_t	current_task = 0;
//
////	Functions Prototype
//void task1_handler(void);
//void task2_handler(void);
//void task3_handler(void);
//void task4_handler(void);
//
//void SysTick_Init(uint32_t tick_hz);
//__attribute__((naked)) void SchedulerStack_Init(uint32_t sched_top_of_stack);
////void TaskStack_Init(void);
//void init_tasks_stack(void);
//void EnableProcessorFaults(void);
//__attribute__((naked)) void Switch_SP_to_PSP(void);
//void save_psp_value(uint32_t current_psp_value);
//void update_next_task(void);
//
//int main()
//{
//	EnableProcessorFaults();
//	SchedulerStack_Init(SCHEDULER_STACK_START);
//	Task_Handler_Address[0] = (uint32_t)task1_handler;
//	Task_Handler_Address[1] = (uint32_t)task2_handler;
//	Task_Handler_Address[2] = (uint32_t)task3_handler;
//	Task_Handler_Address[3] = (uint32_t)task4_handler;
//	//init_tasks_stack();
//	SysTick_Init(TICK_HZ);
//	Switch_SP_to_PSP();
//	task1_handler();
//	while(1);
//	return 0;
//}
//
//void task1_handler(void)
//{
//	while(1)
//	{
//		printf("Task1_Handler\n");
//	}
//}
//void task2_handler(void)
//{
//	while(1)
//	{
//		printf("Task2_Handler\n");
//	}
//}
//void task3_handler(void)
//{
//	while(1)
//	{
//		printf("Task3_Handler\n");
//	}
//}
//void task4_handler(void)
//{
//	while(1)
//	{
//		printf("Task4_Handler\n");
//	}
//}
//
//void SysTick_Init(uint32_t tick_hz)
//{
//	uint32_t countValue = CPU_CLOCK_HZ/tick_hz ;//	Calculate the Count Value
//
//	SYST_RVR = (countValue - 1);				//	Load the Count Value in SysTick Load Register
//
//	SYST_CVR = 0;								//	Clear Current Value
//
//	SYST_CSR &=  ~(BIT(0) | BIT(1) | BIT(2));
//	SYST_CSR |=  (BIT(0) | BIT(1) | BIT(2));	//	Enable SysTick, Enable SysTick Exception, Use Processor Clock
//
//}
//
//__attribute__((naked)) void SchedulerStack_Init(uint32_t sched_top_of_stack)
//{
//	__asm volatile("MSR MSP, %0" : : "r"(sched_top_of_stack) : );	//	Load the starting address of SCHEDULER_STACK to MSP
//	__asm volatile("BX LR");	//	Branch with Link
//}
//
////void TaskStack_Init(void)
////{
////	uint32_t *pPSP = NULL;
////	for(uint8_t i = 0;i < MAX_TASK;i++)
////	{
////		pPSP = (uint32_t *)psp_of_task[i];
////
////		pPSP--;
////		*pPSP = DUMMY_XPSR;	//	0x01000000
////
////		pPSP--;
////		*pPSP = Task_Handler_Address[i];	//	PC
////
////		pPSP--;
////		*pPSP = EXC_RETURN;	//	0xFFFFFFFD;	//	LR
////
////		for(uint8_t j = 0;j < 13;j++)
////		{
////			pPSP--;
////			*pPSP = 0;
////		}
////
////		psp_of_task[i] = (uint32_t)pPSP;
////	}
////}
//void init_tasks_stack(void)
//{
//	uint32_t *pPSP = NULL;
//	for(uint8_t i = 0 ; i < MAX_TASK ; i++)
//	{
//		pPSP = (uint32_t *)psp_of_task[i];
//
//		pPSP--;
//		*pPSP = DUMMY_XPSR; //0x01000000
//
//		pPSP--;	//	PC
//		*pPSP = Task_Handler_Address[i];
//
//		pPSP--;	//	LR
//		*pPSP = 0xFFFFFFFD;
//
//		for(uint8_t j = 0; j < 13; j++)
//		{
//			pPSP--;
//			*pPSP = 0;
//		}
//
//		psp_of_task[i] = (uint32_t)pPSP;
//
//	}
//}
//
//void EnableProcessorFaults(void)
//{
//	//	System Handler Control and Status Register
//	SHCSR |= (BIT(16)|BIT(17)|BIT(18));	//	Enable MEM, BUS & USAGE Fault
//}
//
//uint32_t Get_PSP_Value(void)
//{
//	return psp_of_task[current_task];
//}
//
//void save_psp_value(uint32_t current_psp_value)
//{
//	psp_of_task[current_task] = current_psp_value;
//}
//
//void update_next_task(void)
//{
//	current_task++;
//	current_task %= MAX_TASK;
//}
//
//__attribute__((naked)) void Switch_SP_to_PSP(void)
//{
//    //1. initialize the PSP with TASK1 stack start address
//
//	//get the value of PSP of current_task
//	__asm volatile ("PUSH {LR}"); //preserve LR which connects back to main()
//	__asm volatile ("BL Get_PSP_Value");
//	__asm volatile ("MSR PSP,R0"); //initialize PSP
//	__asm volatile ("POP {LR}");  //pops back LR value
//
//	//2. change SP to PSP using CONTROL register
//	__asm volatile ("MOV R0,#0X02");
//	__asm volatile ("MSR CONTROL,R0");
//	__asm volatile ("BX LR");
//}
//__attribute__((naked)) void SysTick_Handler(void)
//{
//	//	Save the context of current task
//	//	1.	Get current running task's PSP value
//	__asm volatile("MRS R0,PSP");
//	//	2.	Using that PSP value store SF2 (R4 to R11)
//	__asm volatile("STMDB R0!,{R4-R11}");
//	__asm volatile("PUSH {LR}");
//	//	3.	Save the current value of PSP
//	__asm volatile("BL save_psp_value");
//
//
//	//	Retrieve the context of next task
//	//	1.	Decide next task to run
//	__asm volatile("BL update_next_task");
//	//	2.	Get its past PSP value
//	__asm volatile ("BL Get_PSP_Value");
//	//	3.	Using that PSP value retrieve SF2 (R4 to R11)
//	__asm volatile ("LDMIA R0!,{R4-R11}");
//	//	4.	Update PSP & exit
//	__asm volatile("MSR PSP,R0");
//	__asm volatile("POP {LR}");
//	__asm volatile("BX LR");
//}
//
////	Fault Handlers
//void MemManage_Handler(void)
//{
//	printf("ERROR : MemManage_Fault Occurred\n");
//	while(1);
//}
//
//void BusFault_Handler(void)
//{
//	printf("ERROR : Bus_Fault Occurred\n");
//	while(1);
//}
//
//void UsageFault_Handler(void)
//{
//	printf("ERROR : Usage_Fault Occurred\n");
//	while(1);
//}

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#include "led.h"

// Task Handler Function Prototypes
void task1_handler(void); 	//	This is task1
void task2_handler(void); 	//	This is task2
void task3_handler(void); 	//	This is task3
void task4_handler(void); 	// 	This is task4 of the application

void init_systick_timer(uint32_t tick_hz);
__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack);
void init_tasks_stack(void);
void enable_processsor_faults(void);
__attribute__((naked)) void switch_sp_to_psp(void);
uint32_t get_psp_value(void);
void save_psp_value(uint32_t current_psp_value);

uint32_t psp_of_tasks[MAX_TASKS] = {T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START};

uint32_t task_handler[MAX_TASKS];

uint8_t current_task = 0;	//	Task1 is running

int main(void)
{

	enable_processsor_faults();

	init_scheduler_stack(SCHED_STACK_START);

	task_handler[0] = (uint32_t)task1_handler;
	task_handler[1] = (uint32_t)task2_handler;
	task_handler[2] = (uint32_t)task3_handler;
	task_handler[3] = (uint32_t)task4_handler;


	init_tasks_stack();

	led_init_all();

	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();

	task1_handler();

	while(1);
	return 0;
}

void task1_handler(void)
{
	while(1)
	{
		//printf("This is task1\n");
		led_on(LED_GREEN);
		delay(DELAY_COUNT_1S);
		led_off(LED_GREEN);
		delay(DELAY_COUNT_1S);
	}
}

void task2_handler(void)
{
	while(1)
	{
		//printf("This is task2\n");
		led_on(LED_ORANGE);
		delay(DELAY_COUNT_500MS);
		led_off(LED_ORANGE);
		delay(DELAY_COUNT_500MS);
	}
}

void task3_handler(void)
{
	while(1)
	{
		//printf("This is task3\n");
		led_on(LED_BLUE);
		delay(DELAY_COUNT_250MS);
		led_off(LED_BLUE);
		delay(DELAY_COUNT_250MS);
	}
}

void task4_handler(void)
{
	while(1)
	{
		//printf("This is task4\n");
		led_on(LED_RED);
		delay(DELAY_COUNT_125MS);
		led_off(LED_RED);
		delay(DELAY_COUNT_125MS);
	}
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t *pSRVR = (uint32_t *)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

	//	Calculation of reload value
	uint32_t count_value = (SYSTICK_TIM_CLK / tick_hz) - 1;

	//	Clear the value of SVR
	*pSRVR &= ~(0x00FFFFFF);

	//	Load the value into SVR
	*pSRVR |= count_value;

	//	Do some setting
    *pSCSR |= (1 << 1);	//	Enables SysTick exception request:
    *pSCSR |= (1 << 2);	//	Indicates the clock source, processor clock source

	//	Enable the SysTick
    *pSCSR |= (1 << 0);	//	Enable the counter

}

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack)
{
	__asm volatile("MSR MSP,%0": :  "r" (sched_top_of_stack)  :   );
	__asm volatile("BX LR");
}



void init_tasks_stack(void)
{
	uint32_t *pPSP = NULL;
	for(uint8_t i = 0 ; i < MAX_TASKS ; i++)
	{
		pPSP = (uint32_t *)psp_of_tasks[i];

		pPSP--;
		*pPSP = DUMMY_XPSR; //0x01000000

		pPSP--;	//	PC
		*pPSP = task_handler[i];

		pPSP--;	//	LR
		*pPSP = 0xFFFFFFFD;

		for(uint8_t j = 0; j < 13; j++)
		{
			pPSP--;
			*pPSP = 0;
		}

		psp_of_tasks[i] = (uint32_t)pPSP;

	}
}

void enable_processsor_faults(void)
{
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= (1 << 16);	//	mem manage
	*pSHCSR |= (1 << 17);	//	bus fault
	*pSHCSR |= (1 << 18);	//	usage fault
}


uint32_t get_psp_value(void)
{
	return psp_of_tasks[current_task];
}

void save_psp_value(uint32_t current_psp_value)
{
	psp_of_tasks[current_task] = current_psp_value;
}

void update_next_task(void)
{
	current_task++;
	current_task %= MAX_TASKS;
}

__attribute__((naked)) void switch_sp_to_psp(void)
{
    //1. initialize the PSP with TASK1 stack start address

	//get the value of psp of current_task
	__asm volatile ("PUSH {LR}"); //preserve LR which connects back to main()
	__asm volatile ("BL get_psp_value");
	__asm volatile ("MSR PSP,R0"); //initialize psp
	__asm volatile ("POP {LR}");  //pops back LR value

	//2. change SP to PSP using CONTROL register
	__asm volatile ("MOV R0,#0X02");
	__asm volatile ("MSR CONTROL,R0");
	__asm volatile ("BX LR");
}

__attribute__((naked)) void SysTick_Handler(void)
{
	//	Save the context of current task

	//	1.	Get current running task's PSP value
	__asm volatile("MRS R0,PSP");
	//	2.	Using that PSP value store SF2 (R4 to R11)
	__asm volatile("STMDB R0!,{R4-R11}");

	__asm volatile("PUSH {LR}");

	//	3.	Save the current value of PSP
	__asm volatile("BL save_psp_value");


	//	Retrieve the context of next task

	//	1.	Decide next task to run
	__asm volatile("BL update_next_task");
	//	2.	Get its past PSP value
	__asm volatile ("BL get_psp_value");
	//	3.	Using that PSP value retrieve SF2 (R4 to R11)
	__asm volatile ("LDMIA R0!,{R4-R11}");
	//	4.	Update PSP & exit
	__asm volatile("MSR PSP,R0");
	__asm volatile("POP {LR}");
	__asm volatile("BX LR");
}

// Implement the fault handlers
void HardFault_Handler(void)
{
	printf("Exception : Hardfault\n");
	while(1);
}

void MemManage_Handler(void)
{
	printf("Exception : MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception : BusFault\n");
	while(1);
}
