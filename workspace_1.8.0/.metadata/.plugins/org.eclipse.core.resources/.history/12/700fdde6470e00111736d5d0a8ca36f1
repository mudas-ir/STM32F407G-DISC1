///**
// ******************************************************************************
// * @file           : main.c
// * @author         : Mudassir
// * @brief          : Main program body
// ******************************************************************************
// * @attention
// *
// * Copyright (c) 2026 STMicroelectronics.
// * All rights reserved.
// *
// * This software is licensed under terms that can be found in the LICENSE file
// * in the root directory of this software component.
// * If no LICENSE file comes with this software, it is provided AS-IS.
// *
// ******************************************************************************
// */
//
//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif
//
//#include <stdio.h>
//#include <stdint.h>
//#include "main.h"
//
////	Global Variables
//uint32_t psp_of_task[MAX_TASK] = {TASK1_STACK_START, TASK2_STACK_START, TASK3_STACK_START, TASK4_STACK_START};
//uint32_t Task_Handler_Address[MAX_TASK];
//uint8_t	current_task = 0;
//
////	Functions Prototype
//void task1_handler(void);
//void task2_handler(void);
//void task3_handler(void);
//void task4_handler(void);
//
//void SysTick_Init(uint32_t tick_hz);
//__attribute__((naked)) void SchedulerStack_Init(uint32_t sched_top_of_stack);
////void TaskStack_Init(void);
//void init_tasks_stack(void);
//void EnableProcessorFaults(void);
//__attribute__((naked)) void Switch_SP_to_PSP(void);
//void save_psp_value(uint32_t current_psp_value);
//void update_next_task(void);
//
//int main()
//{
//	EnableProcessorFaults();
//	SchedulerStack_Init(SCHEDULER_STACK_START);
//	Task_Handler_Address[0] = (uint32_t)task1_handler;
//	Task_Handler_Address[1] = (uint32_t)task2_handler;
//	Task_Handler_Address[2] = (uint32_t)task3_handler;
//	Task_Handler_Address[3] = (uint32_t)task4_handler;
//	//init_tasks_stack();
//	SysTick_Init(TICK_HZ);
//	Switch_SP_to_PSP();
//	task1_handler();
//	while(1);
//	return 0;
//}
//
//void task1_handler(void)
//{
//	while(1)
//	{
//		printf("Task1_Handler\n");
//	}
//}
//void task2_handler(void)
//{
//	while(1)
//	{
//		printf("Task2_Handler\n");
//	}
//}
//void task3_handler(void)
//{
//	while(1)
//	{
//		printf("Task3_Handler\n");
//	}
//}
//void task4_handler(void)
//{
//	while(1)
//	{
//		printf("Task4_Handler\n");
//	}
//}
//
//void SysTick_Init(uint32_t tick_hz)
//{
//	uint32_t countValue = CPU_CLOCK_HZ/tick_hz ;//	Calculate the Count Value
//
//	SYST_RVR = (countValue - 1);				//	Load the Count Value in SysTick Load Register
//
//	SYST_CVR = 0;								//	Clear Current Value
//
//	SYST_CSR &=  ~(BIT(0) | BIT(1) | BIT(2));
//	SYST_CSR |=  (BIT(0) | BIT(1) | BIT(2));	//	Enable SysTick, Enable SysTick Exception, Use Processor Clock
//
//}
//
//__attribute__((naked)) void SchedulerStack_Init(uint32_t sched_top_of_stack)
//{
//	__asm volatile("MSR MSP, %0" : : "r"(sched_top_of_stack) : );	//	Load the starting address of SCHEDULER_STACK to MSP
//	__asm volatile("BX LR");	//	Branch with Link
//}
//
////void TaskStack_Init(void)
////{
////	uint32_t *pPSP = NULL;
////	for(uint8_t i = 0;i < MAX_TASK;i++)
////	{
////		pPSP = (uint32_t *)psp_of_task[i];
////
////		pPSP--;
////		*pPSP = DUMMY_XPSR;	//	0x01000000
////
////		pPSP--;
////		*pPSP = Task_Handler_Address[i];	//	PC
////
////		pPSP--;
////		*pPSP = EXC_RETURN;	//	0xFFFFFFFD;	//	LR
////
////		for(uint8_t j = 0;j < 13;j++)
////		{
////			pPSP--;
////			*pPSP = 0;
////		}
////
////		psp_of_task[i] = (uint32_t)pPSP;
////	}
////}
//void init_tasks_stack(void)
//{
//	uint32_t *pPSP = NULL;
//	for(uint8_t i = 0 ; i < MAX_TASK ; i++)
//	{
//		pPSP = (uint32_t *)psp_of_task[i];
//
//		pPSP--;
//		*pPSP = DUMMY_XPSR; //0x01000000
//
//		pPSP--;	//	PC
//		*pPSP = Task_Handler_Address[i];
//
//		pPSP--;	//	LR
//		*pPSP = 0xFFFFFFFD;
//
//		for(uint8_t j = 0; j < 13; j++)
//		{
//			pPSP--;
//			*pPSP = 0;
//		}
//
//		psp_of_task[i] = (uint32_t)pPSP;
//
//	}
//}
//
//void EnableProcessorFaults(void)
//{
//	//	System Handler Control and Status Register
//	SHCSR |= (BIT(16)|BIT(17)|BIT(18));	//	Enable MEM, BUS & USAGE Fault
//}
//
//uint32_t Get_PSP_Value(void)
//{
//	return psp_of_task[current_task];
//}
//
//void save_psp_value(uint32_t current_psp_value)
//{
//	psp_of_task[current_task] = current_psp_value;
//}
//
//void update_next_task(void)
//{
//	current_task++;
//	current_task %= MAX_TASK;
//}
//
//__attribute__((naked)) void Switch_SP_to_PSP(void)
//{
//    //1. initialize the PSP with TASK1 stack start address
//
//	//get the value of PSP of current_task
//	__asm volatile ("PUSH {LR}"); //preserve LR which connects back to main()
//	__asm volatile ("BL Get_PSP_Value");
//	__asm volatile ("MSR PSP,R0"); //initialize PSP
//	__asm volatile ("POP {LR}");  //pops back LR value
//
//	//2. change SP to PSP using CONTROL register
//	__asm volatile ("MOV R0,#0X02");
//	__asm volatile ("MSR CONTROL,R0");
//	__asm volatile ("BX LR");
//}
//__attribute__((naked)) void SysTick_Handler(void)
//{
//	//	Save the context of current task
//	//	1.	Get current running task's PSP value
//	__asm volatile("MRS R0,PSP");
//	//	2.	Using that PSP value store SF2 (R4 to R11)
//	__asm volatile("STMDB R0!,{R4-R11}");
//	__asm volatile("PUSH {LR}");
//	//	3.	Save the current value of PSP
//	__asm volatile("BL save_psp_value");
//
//
//	//	Retrieve the context of next task
//	//	1.	Decide next task to run
//	__asm volatile("BL update_next_task");
//	//	2.	Get its past PSP value
//	__asm volatile ("BL Get_PSP_Value");
//	//	3.	Using that PSP value retrieve SF2 (R4 to R11)
//	__asm volatile ("LDMIA R0!,{R4-R11}");
//	//	4.	Update PSP & exit
//	__asm volatile("MSR PSP,R0");
//	__asm volatile("POP {LR}");
//	__asm volatile("BX LR");
//}
//
////	Fault Handlers
//void MemManage_Handler(void)
//{
//	printf("ERROR : MemManage_Fault Occurred\n");
//	while(1);
//}
//
//void BusFault_Handler(void)
//{
//	printf("ERROR : Bus_Fault Occurred\n");
//	while(1);
//}
//
//void UsageFault_Handler(void)
//{
//	printf("ERROR : Usage_Fault Occurred\n");
//	while(1);
//}
